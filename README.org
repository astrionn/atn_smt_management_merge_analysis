


*** atn smt management software project
#+EXPORT_FILE_NAME: README.html
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

This application assists three real life workflows to receive, store and use SMD materials in an industrial SMT process to manufacture *boards*.


*Boards* are manufactured in a *machine* from multiple *carriers* each storing an amount of an *article*.


Each *board* is represented as a a list of *article*-count pairs, this is also called bill of materials.


*Carriers* need to be ordered from a *provider*, received, stored and collected for a *job*, used in a *job* and re-stored or discarded.
The ordering part is outside the scope of this application. The user imports orders of *carriers* after the order process has been done in real life. 


*Carriers* usually have the dimension of a cylinder and have properties like diameter and width. This is relevant for storing in a *storage* or a *machine* .
A *carrier* is identified by its UID, a sticker/label containg the UID and a QR Code of the UID is placed on the carrier by the user after an order of *carriers* is delivered at the manufacturing facility but before they are stored..


A *provider* is the entity that delivers *carriers* to the manufacturing facility.


A *manufacturer* is the entity that produces *carriers* that are delivered by a *provider*.


A *carrier* can be stored in the *storage* *slot* of a *storage* or the *machine* *slot* of a *machine*.


A *job* is manufacturing a *board* a number of times in a certain time frame. A *job* can be part of a *project* and can have *customers*.


A *machine* is a pick'n'place machine it produces *boards* from *carriers*. Akin to a 3D printer, which uses filament to print objects layer by layer, a pick'n'place *machine* "prints" *boards* *article* by *article*.
Like *storage*, a *machine* has *machine* *slots*.

A *storage* is a shelf with *storage* *slots*, each slot has an LED that can be activated by this application.

**** Backend                                                    

The backend will be provided with the django library in python 3.11 64bit
It is contained in the www\python folder.
***** set up
How to install the backend
- Open Powershell
  #+begin_src
  cd www\python
#+end_src
- create a venv for python 3.11
   #+begin_src 
  py -3.11 -m venv venv
  .\venv\Scrips\activate
#+end_src

- start django project and create app
  #+begin_src
    .\venv\Scripts\python.exe -m django startproject atn_smt_management
    .\venv\Scripts\python.exe -m django startapp atn_smt_management_app
  #+end_src
- created files
  #+begin_src


- modify settings.py
  Do this manually.
  #+CAPTION: =add rest_framework to settings.py=
  #+begin_src python
        INSTALLED_APPS.append("rest_framework")
        INSTALLED_APPS.append("django_filters")
        INSTALLED_APPS.append("corsheaders")
        INSTALLED_APPS.append("smt_management_app.apps.SmtManagementAppConfig")

        MIDDLEWARE.append("corsheaders.middleware.CorsMiddleware")

        CORS_ORIGIN_ALLOW_ALL = True
        CORS_ALLOWED_HEADERS = ['*']
        ALLOWED_HOSTS = ['*']


        REST_FRAMEWORK = {
        'DEFAULT_FILTER_BACKENDS': (
            'django_filters.rest_framework.DjangoFilterBackend',
        ),
        'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
        'PAGE_SIZE': 100
    }




  #+end_src

- choose which shelf device is needed

  There are 3 different libraries for 3 different shelfs at the moment.
  
  Neolight Smart Shelf(neolight_handler.py) , Sophia PTL (xgatehandler.py) and ATNs own implementation PTLHandler.py

  For developement purposes you can find a dummy class at the top of views.py, modify accordingly.

 - enable/disable the label printer

   for developement I highly recommend not enabling the printer, you can find it in the same try/catch block at the top of views.py
***** notes for refactoring
does carrier fit into slot for storage?
**** Frontend
***** Initial Draft containing description of functionality, API templates, Screenshots
****** login
The user starts with a simple login form.
******* plain
[[./1.PNG]]
******* login failed
[[./2.PNG]]
****** dashboard
Upon login the user gets to the dashboard which presents usefull data like outstanding deliveries, storage capacity and the number of open jobs.

From there the user can navigate to the 4 main pages: dashboard, material entry, material storage and setup center.

The admin tile wont be required.

The tiles should be clickable and redirect to the other pages.

The left sidebar contains routing buttons to the 4 pages(dashboard,material entry, material storge, setup center).


[[./3.PNG]]
[[./3a.PNG]]

****** material entry
This page facilitates three main functions, entering new orders into the system, tracking order status and marking carriers as delivered.


An order is usually a comma seperated list of carriers, rarely it is a singular carrier.


The user can enter an order into the system by uploading a csv file containing the ordered carriers row by row, each row representing one carrier.
The first row, as an exception, should contain the column headers names of the file, which do not have to match the form fields.


If the user uploads a csv file via the import button, he is then tasked to map the form field names to the column headers of the csv file.


This mapping is remembered and will be provided as default values for future mappings.


The user can also add a singular carrier via a form.


One carrier always only carries one type of article.
Therefore before a carrier can be created the article needs to be created.


The main body of the page is a table displaying all carriers even the ones that have been ordered and not yet delivered.
The table supports filtering by column criteria like delivery status or lot number.

In the header of the table is a field which would usually be a search bar but it provides a way to tick the selection box of a row.

#+begin_example
If there is a value entered and confirmed with return, the row which has the entered value as the carrier uid field is added to the selection, i.e. the selection box of that row is ticked.

Entering the carrier UID and pressing enter will be beformed by a handheld scanner, this enables quickly selecting carriers in the table by scanning their QR Codes in real life.
#+end_example

The header of the table also provides 3 actions for the selected rows and 2 general actions.

- The selection can be set as delivered.
- The selection can be printed. (labels containg the carrier UID as a QRCode)
- The selection can be deleted.




The next table header button allows hiding/showing the columns of the table.
The final button exports the current view of the table, kind of like a screenshot, has nothing to do with the selection.


The workflow is as follows:

1. Order carriers and receive an order number outside of this application
2. Add carriers via form or file, supplying the order number as lot number
3. Wait for arrival of order
4. Filter carriers by ~lotnumber=order number~ and ~delivered=False~

   The user will upon receiving a delivery filter for the delivery number, or lotnumber.
   He may narrow it down further by filtering for e.g. manufacturer or provider.
   If a delivery only has been partially processed the user may filter for delivery status.
5. Select all and print the labels.

   Printing a selection deselects all carriers and places the cursor in the "search box".
6. Stick a label on the carrier and scan it (row gets selected)
   The user steps away from the application only having a handheld scanner as remaining input device to the application.
   The user then proceeds to stick a sticker on the corresponding carrier.
   The user uses the scanner and scans the qr code on the label that just has been placed on the carrier, this selects the row of the carrier in the application.
7. repeat 6. until all labels are used
8. set selection as delivered
   The user returns to the application and sees all teh carriers he has just labelled selected in the table.
   The user presses the icon with the little arrow in the toolbar of the table, this changes the status of delivered from False to True.
   Delivering a selection resets all filters of the table.
******* screens
******** plain

[[./4.PNG]]

******** add single article
[[./5.PNG]]
********* success
no screenshot : snackbar notification in green with success message

********* fail - form
[[./5a.PNG]]
********* fail - server
no screenshot : snackbar notification in red with error message

******** add csv articles
The first click opens a file upload window, afterewards the column selector.
[[./8.PNG]]
********* success
im open for a better way to design the notification
[[./8a.PNG]]

********* fail - file upload
general file upload error
********* fail - server
error while processing the file since data is malformed or not well defined



******** add single carrier 
see add single article
********* success
********* fail - form
********* fail - server

******** add csv carriers 
see add csv carriers
********* success
********* fail - file

********* fail - server


******** with data 
ignore the snackbar notification on the bottom
[[./8a.PNG]]

****** material storage
This page facilitates the users physical interaction with the storages. Mainly adding a carrier to a storage, collecting a carrier from a storage, deleting a carrier and collecting multiple carriers at once.


A storage consists of storage slots each with an unique id, each slot also has an LED and a qrcode with the storageslot ID.


Delivered carriers can be stored in the selected storage by entering their UID into the add field and pressing return.


The user is then presented with a popup, within the ID of a storageslot is displayed.
The LED of that storageslot is blinking green while the popup is displayed.


The user is expected to put the carrier into the slot with the blinking LED and is expected to scan the QR code of the slot, containing its ID.
The scanning action is the same as the user inputing the slots ID via the keyboard and pressing enter.


Closing the popup cancels the attempt to add to storage and kills teh LED.
If the user scans/enters the wrong slot ID, he can try again until success. 


A carrier can be displayed via the display field. The carrier data is editable and saveable. The label is printable from here. The LED is turned green while displaying component is mounted.


A carrier can be retrieved from storage by entering their UID in the collect field.


The corresponding storage and storageslot will be displayed to the user and the LED will start blinking blue until its storageslot ID has been scanned.


If there are multiple carriers being collected a queue is displayed showing the storage slots which have not been scanned.
This queue can also be filled with the collect job field after finishing the pre-setup step of the setup center workflow.


The queue should be a collapsable text field containing carrier UIDs - storage slot IDs pairs.
It displays all the carriers that have been added to the queue whose corresponding storage slot ID has not been scanned.


Scanning a storage slot ID removes it from the queue and kills the LED.


A carrier can also be deleted from the system - when its discarded in real life.


The main body of the page shows the different storages and machines and their contents in collapsable tables.


The tables support the same functionality as the previous tables including the not-search-but-select box and header buttons to collect, delete or display(just LEDs) the selection.



******* plain
[[./9.PNG]]

[[./10.PNG]]
******* plain with some data in a shelf

[[./11.PNG]]

******* display carrier 
[[./12.PNG]]

******** edit carrier
no screenshots, editable fields, some with suggestions others type restrictions
success and fail messages via colored snackbar
********* success
********* fail

******* add

******** confirm slot
no screenshot, popup component indicating the storage and slot to scan.

******** success

[[./14.PNG]]

******** fail

[[./13.PNG]]
[[./15.PNG]]

******* collect
In this example at least 3 carriers are in the collect queue, if any of the corresponding storageslot IDs is scanned it is taken from the queue and the correspondance is lifted.

If another carrier UID would be entered the queuecount would increase to 5 and a snackbar notification with the storageslot info gets shown.

A way to list the actual UIDs in the queue would be nice, refer to above.

Just for clarification: it is not an actual queue but a set, but the terminology is established already.

[[./18.PNG]]
******** success
no screenshot.
green snackbar notification that indicates scanning of the correct slot,  table update


******** fail
********* carrier not found

[[./17.PNG]]

********* wrong slot scanned try again

slot contains no carrier in the collect queue 

******* delete
******** success
[[./16.PNG]]

******** fail 
********* carrier doesnt exist
[[./17.PNG]]
****** setup_center
This page facilitates creating jobs, allocating carriers to them and finishing them.

The basis of each job or board is a list of article-count pairs.

This list can be provided as a csv file or entered manually.

Additionally a job has an assigned machine, time slot, a count and a status.

After a job with his parameters has been created a carrier for each article needs to be chosen which will be marked as reserved - this is called pre-setup.

Once the pre-setup is complete the carriers of a job can be collected from the material_storage page.

After that the production process in the real world happens.
After the job is finished the user provides the actual usage of articles for each carrier and an optional note.
By marking a jopb conpleted the carriers are no longer marked as reserved and need to be restored, discarded or left on the machine for the next job if applicable.


The typical user workflow looks like this:

1. create job
2. assign carriers to job
3. collect carriers
4. do the production process in the real world
5. mark job as completed and note usage
6. re-store the carriers


******* plain

[[./20.PNG]]

******* create job
[[./21.PNG]]
[[./22.PNG]]
[[./25.PNG]]
******** time and date picker
[[./23.PNG]]


******** timeline of scheduled jobs

[[./31.png]]

******** upload csv

no screenshot, but same as on material entry: first the user uploads a file and then a component is mounted so the user can map column headers to field names
with according snackbar notifications
******** fail

********* input error

[[./24.PNG]]

********* server file error

notification with error

******* pre setup
add  progressbar

entry = article entry on the left side
******** BOM no entry selected

[[./26.PNG]]

******** BOM entry selected 
shows available carriers
********* carriers displayed, some with warning
[[./27.PNG]]

********* no carriers available
[[./1.gif]]

********* carrier selected
[[./28.PNG]]
********* all carriers selected
[[./32.PNG]]


******* finish job

[[./29.PNG]]

******* multiple jobs with different color coding based on state: scheduled, pre-setup-done, collected, finished

[[./30.PNG]]

